----------------
> Week 1. (2022.12.26 - 2023.01.02)
### 1-1. 잃어버린 괄호
- Greedy
    - 한참 걸렸음. 반성하고 더 열심히 하자...
    - 처음에 괄호를 다 넣는 방향으로 생각
    - 그러다가 '-' 뒤 숫자를 전부 음수로 계산해주면 된다는 것을 깨달음
    - 그건 어렵지 않다고 생각했는데 솔직히 오래 걸렸음.
    - 코드를 짧게 만들고 싶다는 욕심을 버려야 시간을 아낄 수 있을듯.
    - 욕심 버리고 문제 푸는 데에만 집중하자.

### 1-2. 바닥 장식
- DFS
    - '-' 부호와 '|' 부호를 서로 다른 dfs로 좌우 혹은 상하로만 전파
    - if문으로 break 설정할 때, visited[x][y] == 1을 넣으면 안되는데 왜 안 되는지 아직 생각을 못해봄. 나중에 생각해볼 것
### 1-3. 소문난 칠공주
- BFS
    - 보류
---------------------
> Week 2. (2023.01.03 - 2023.01.09)
### 2-1. 방탈출
- BFS
    - 처음에 bfs를 모든 시작점과 끝점의 조합을 찾아서 풀려고 했는데 시간초과
    - 시작점만 사용하면 된다는 걸 깨달음.
    - 왜냐면 bfs로 시작점만 설정해주면 시작점으로부터 가장 먼 좌표까지 일단 모두 방문하게 되고 그거에 대한 visit 함수 덕에 최단 경로가 저절로 저장되기 때문
    - 그리고 그래프에서 0인 좌표는 시작점으로 쓸 수 없기 때문에 이중반복문으로 bfs를 전부 확인하지 않고 graph[i][j] != 0인 (i, j)만 리스트에 저장해서 그 리스트만 bfs로 확인함
    - 그 리스트를 통해 MAX distance를 업데이트 해가면서 새로운 MAX distance가 등록될 때마다 패스워드도 업데이트 함.

### 2-2. 현수막
- DFS
    - sys.setrecursionlimit(10**6) 해줘야 함
    - 8 방향으로 확인한다는 점 외에는 특이사항 없었음
    - 이중 반복문을 사용하여 모든 좌표에서 dfs 출발시키고, dfs가 퍼지는 행동을 하면 return 1로 만들어서 모든 1을 합함
---------------------
> Week 3. (2023.01.09 - 2023.01.16)
### 3-1. 적록색약
- DFS
    - 적록색약인 사람, 아닌 사람 용 dfs 두 개로 함수를 나눠서 풀이하니 쉬웠음
    - 하나의 함수 안에서 두 그래프를 동시에 고려할 방법을 생각해보면 좋을 것 같음.
![풀이 p.1](https://user-images.githubusercontent.com/69744314/211463439-d3c9abc2-43c5-4420-941e-110e6f6e6cd5.jpg)
![풀이 p.2](https://user-images.githubusercontent.com/69744314/211463441-ea24a2f3-a6da-4d70-820c-36468a6b86dc.jpg)

### 3-2. 보물섬
- BFS
    - 구현 자체는 방탈출보다 쉬웠음
    - 문제는 통과했지만 시간이 오래 걸려서 찾아보니, 맵에서 상하나 좌우 지형이 모두 'L'이면 더 갈 수 있는 땅이 있으므로 가장 먼 거리가 될 수 없음.
    - 그래서 그 좌표를 제외해줌으로써 시간을 8분의 1로 줄일 수 있었음.
    - 다들 이러한 유형 (가장 먼 최단경로 찾기) 문제를 만났을 때, 이 방법을 써서 시간 효율을 확보하면 좋겠음.

---------------------
> Week 4. (2023.01.16 - 2023.01.23)
### 4-1. ABCDE
- DFS
    - 너무 쉬워보였는데 백트래킹 원리에 의해 return문이 안 먹어서 매우 당황
    - 하루종일 return을 어떻게 해결해야 되나 머리 싸매다가 안 풀려서 나린이의 sys.exit() 힌트를 받고 해결함.
    - 백트래킹에 대해 더 제대로 이해한 것 같고, sys.exit()의 파괴성도 깨달음
![풀이 4-1-1](https://user-images.githubusercontent.com/69744314/213415556-ba3ed8f5-9b9d-4673-83bd-e9f9167d498d.jpg)
![풀이 4-1-2](https://user-images.githubusercontent.com/69744314/213415563-f832bbb0-c358-4f65-8796-601270f51057.jpg)

### 4-2. 회장뽑기
- BFS
    - 처음에 dfs라고 생각했다가, 가장 긴 최단거리를 찾으면 된다는 아이디어로부터 bfs임을 파악.
    - input을 어떻게 스탑해야할까 어렵다고 생각했는데, break로 하면 됨을 금방 깨달음. 근데 input문 뒤에 split 안 해서 처음에 오류 발생
    - 그 다음 회장뽑기 멤버 번호가 1부터 n인거 때문에 visit 기록하는 데 오류 발생 했던 점 처음에 놓침. 하지만 금방 찾아서 해결
    - 리스트 컴프리헨션에서 조건문 위치를 잘못 써서 또 문제 발생했지만 금방 고침.
![풀이 4-2-1](https://user-images.githubusercontent.com/69744314/213637251-78c54b54-8ca9-433f-9ee5-954ecbfcfd19.jpg)
![풀이 4-2-2](https://user-images.githubusercontent.com/69744314/213637256-4339f80f-a394-4916-bba3-14c1b8d51bc5.jpg)

---------------------
> Week 5. (2023.01.23 - 2023.01.30)
### 5-1. 물통
- DFS
    - 그래프 구조가 막막해서 나린이가 저번주에 알려준 거스름돈 문제로 생각해보려 함.
    - 근데 그건 잘 대입이 안돼서, 그래프 노드를 세 숫자의 리스트로 생각해봄. 킹능성 느껴져서 풀이 돌입
    - 각 노드에서 뻗어나갈 수 있는 경우의 수가 6가지 임을 파악 -> moves라는 리스트에 6가지 경우의 수 기록
    - visit을 기존에 했던 방식으로 하면 최대 길이 4백만의 리스트를 만들어야 돼서 그냥 visit을 빈 리스트로 생성하고 추가하는 방식으로 진행함.
        - 시간 효율성이 떨어질 줄 알았는데 영향이 적었음. 실제로 방문하는 노드가 많지 않아서 가능했던 것 같음
    - 옮길 물통과 옮겨질 물통, 용량 한계 등 용량 계산이 은근 헷갈렸지만 침착하게 생각해서 해결
    - for문 밖에서 현재 물통의 용량을 리스트로 기록한 부분에서 문제 발생 -> 너무 헷갈려서 한 시간동안 고민 -> for문 안에서 후보 리스트를 만드는 방식으로 해결
    - 결국 2시간 만에 해결

![풀이 5-1-1](https://user-images.githubusercontent.com/69744314/214506487-2abcded2-7d1f-4830-854f-e663db939083.jpg)
![풀이 5-1-2](https://user-images.githubusercontent.com/69744314/214506489-377ac23d-3867-401f-b36a-4dba3997787a.jpg)
![풀이 5-1-3](https://user-images.githubusercontent.com/69744314/214506471-5ddda4dd-091e-4d70-814c-54fa7501584b.jpg)
![풀이 5-1-4](https://user-images.githubusercontent.com/69744314/214506484-1e4ac892-92da-4130-843f-daa4337a76b1.jpg)
![풀이 5-1-5](https://user-images.githubusercontent.com/69744314/214506486-822a28cb-a2fd-4823-8107-b595ffa45c94.jpg)

### 5-2. 노드사이의 거리
- BFS
    - 네임에러가 떠서 수차례 확인했는데 visit = [0] * (n+1) 라인에서 = 할당을 빼먹고 있었음;
    - 처음에 그냥 2차원 리스트로 풀다가 시간초과가 나서 조회하는 시간이 오래 걸림을 파악하고 graph를 해시로 수정
    - 사실 graph 아니고 tree인데 구분 안 하고 습관적으로 명명해버림.
    - 이 문제에서 주어진 자료구조가 tree이기 때문에 visit을 초기화해줄 필요가 없었음. (다른 루트가 있는지 찾아보지 않더라도 문제가 되지 않았음.)
    → 왜냐면 트리구조에서는 출발한 노드에서 특정 노드로 가는 길이 하나밖에 없으므로. 

### 5-3. 숨바꼭질 3 (도전 문제)
- 다이나믹 프로그래밍
    - BFS인 줄 알고 시작했지만 아니었음. BFS로 풀다가 한계 봉착하여 답안 참고
    - 참고했던 풀이 세가지 중에서 bfs로 푸는 문제는 마지막 풀이로 풀면 2의 거듭제곱을 전부 큐에 추가하고 효율성이 많이 떨어짐.
    - visit과 dist를 한 번에 체크하는 방법을 사용할 수 있다는 것을 배웠음
    - 100000이라는 숫자 제한이 있으므로 이를 활용
    - 곱하기 2에 해당하는 위치는 가중치가 0이므로 이를 appendleft로 큐에 우선적으로 추가해주는 방법이 있다는 것을 깨달음

### 5-4. (개인문제) 토마토
- BFS
    - 문제 자체는 쉽게 풀었는데, 멍청하게 print()를 안 써가지고 계속 틀려서 시간 낭비함.
    - 온갖 반례 다 확인하면서 찾아봤는데 다 맞아서 도대체 뭘 틀린건지 고민하다가.. 허무했음.
    - print() 해야 출력된다 멍청이..
### 5-5. (개인문제) 트리
- DFS
    - 완벽하게 풀었다고 생각했는데 78%에서 자꾸 틀림. 알고보니 반례를 놓치고 있었음
    - 반례: 노드를 끊었을 때 끊긴 부분을 저장하지 확인하지 않는 문제
    - 3
    - -1 0 1
    - 2
    - Answer: 1
    - 오답: 2
    - 항상 가능한 모든 경우의 수를 잘 고려하자.
### 5-6. (개인문제) 연구소
- DFS, BFS
    - 옛날에 풀었던 문제인데 다시 풀어봤지만 시간초과를 이겨내지 못함.
    - 접근 방법이 기억나서 비슷하게 했으나, 시행착오 많았음.
    - 새로운 풀이도 찾아봤는데 컷엣지를 어떻게 써서 시간을 줄였는지 알 수 있었음.
    - 근데 실전 코테를 보게 된다면 컷엣지 고민에 시간을 많이 투자할 수 없을 것 같음
    - 컷엣지까지 하려면 수리, 논리적으로 좀 더 엄밀하게 접근해야 해서 시간 투자를 많이 해야하기 때문.
---------------------
> Week 6. (2023.01.30 - 2023.02.06)
### 6-1. 그래프 탐색
- BFS
    - 시간복잡도 상당히 높은 문제였음. 하지만 한번에 통과함
    - input으로 입력한 q개의 도로 상태를 그래프에 업데이트 한 후 그때의 경로를 개별적으로 찾아야 해서 시간복잡도 엄청 높은 듯 (경로 찾기 위한 while문 * q번)
    - 그래서 만약에 이중리스트로 조회하면 무조건 시간초과 날 듯
    - 1에서 출발하면서 각 도시가 조회될 때마다 기록한 것도 괜찮은 방법이었던 것 같음
    - input 하면서 함수를 적용하는 것은 처음이었는데 잘 생각한 듯
    - 시간 복잡도 더 줄이는 방법은 생각해봤는데, dict 키에서 1을 빼고 저장하면 조금 줄긴 할 거 같은데 그리 많이 줄 것 같지는 않음
### 6-2. 연결 요소의 개수
- BFS
    - 시간복잡도 높을 것으로 예상됐지만 그냥 그래프 탐색 하위문제 같아서 그대로 풂
    - 시간복잡도 역시 높아서 PyPy3로 바꾸고 함. 시간복잡도 줄일 노력은 따로 안 했는데 얘기해보면 좋을 것 같음

> Week 7. (2023.02.06 - 2023.02.13)
- DP
    - 다이나믹 프로그래밍 자체는 이해하지 못했지만, 리스트에 층을 업데이트 한다고 생각했음
    - 뿌듯